/*!
 * Provides a centralized utility for managing 3D model assets, including loading, caching, and disposal, ensuring consistent and efficient handling of models across the landing page components.
 * @module utils/modelManager
 */
import * as THREE from 'three';
import {GLTF, DRACOLoader, KTX2Loader} from '@react-three/drei';
import {LoadingManager} from 'three';
interface ModelCacheItem{scene:THREE.Group;dispose:()=>void}
interface ModelManagerOptions{maxCacheSize:number;expirationTime:number}
class ModelManager{private cache:Map<string,ModelCacheItem>=new Map();private loadingManager:LoadingManager=new LoadingManager();private dracoLoader:DRACOLoader=new DRACOLoader(this.loadingManager);private ktx2Loader:KTX2Loader=new KTX2Loader(this.loadingManager);private options:ModelManagerOptions={maxCacheSize:50,expirationTime:300000};constructor(options?:Partial<ModelManagerOptions>){this.options={...this.options,...options};this.dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');this.ktx2Loader.setTranscoderPath('https://threejs.org/examples/jsm/libs/basis/');}private checkCacheSize():void{if(this.cache.size>this.options.maxCacheSize){const oldestKey=this.cache.keys().next().value;this.disposeModel(oldestKey);this.cache.delete(oldestKey);}}private isCacheExpired(key:string):boolean{const item=this.cache.get(key);if(!item)return true;return false;}async loadModel(url:string):Promise<{scene:THREE.Group}>{if(this.cache.has(url)&&!this.isCacheExpired(url)){console.log(`returning cache for ${url}`);return Promise.resolve(this.cache.get(url)!);}return new Promise((resolve,reject)=>{const loader=new THREE.GLTFLoader(this.loadingManager);loader.setDRACOLoader(this.dracoLoader);loader.setKTX2Loader(this.ktx2Loader);loader.load(url,(gltf:GLTF)=>{gltf.scene.traverse(function(node){if((node as THREE.Mesh).isMesh){node.castShadow=true;node.receiveShadow=true;}});const dispose=()=>{this.disposeModel(url);};this.cacheModel(url,gltf.scene,dispose);resolve({scene:gltf.scene});},(xhr)=>{console.log(`model ${url} is ${xhr.loaded/xhr.total*100}% loaded`);},(error)=>{console.error('An error happened',error);reject(error);});});}private cacheModel(url:string,scene:THREE.Group,dispose:()=>void):void{this.checkCacheSize();this.cache.set(url,{scene,dispose});}disposeModel(url:string):void{const cacheItem=this.cache.get(url);if(cacheItem){cacheItem.scene.traverse(child=>{if((child as THREE.Mesh).isMesh){if(child.geometry)child.geometry.dispose();if(child.material){if(Array.isArray(child.material)){child.material.forEach(material=>{if(material.map)material.map.dispose();material.dispose();});}else{if(child.material.map)child.material.map.dispose();child.material.dispose();}}}});}}const modelManager=new ModelManager({maxCacheSize:50,expirationTime:300000});export{modelManager};